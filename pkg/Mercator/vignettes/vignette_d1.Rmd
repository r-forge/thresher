---
title: "Using the Mercator Package"
author: "Kevin R. Coombes, Zachary B. Abrams, C.E. Coombes, Suli Li"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: yeti
    highlight: kate
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, results="hide"}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
Modern biological experiments are increasingly producing interesting
binary matrices. These may represent the presence or absence of
specific gene mutations, copy number variants, microRNAs, or other
molecular or clinical phenomena. We have recently developed a tool, *CytoGPS*,
that converts conventional karyotypes from the standard text-based
notation (the International Standard for Human Cytogenetic Nomenclature;
ISCN) into a binary vector with three bits (loss, gain, or fusion) per
cytoband, which we call the "LGF model".

The *Mercator* package is intended to facilitate the
exploration of binary data sets. It implements a subset of the 76
binary distance metrics described by [Choi and colleagues], ensuring that
at least one representative of each of their major clusters is
included. Each resulting distance matrix can be combined with multiple
visualiization techniques, providing a consistent interface to
thoroughly explore the data set.

# The BinaryMatrix Object Class

First we load the R library package *Mercator*.
```{r library}
library(Mercator)
suppressWarnings( suppressMessages( library(Thresher) ))
```

```{r path}
#We need to decide where to store the test data set and set the path.
```

### A Limited, Sample Dataset
We proceed with a model dataset of karyotypes from patients with Chronic Myelogenous Leukemia (CML) with 400 chromosomal features recorded over 
740 patients, from the public
Mitelman database. Cytogenetic abnormalities, recorded in Mitelman as text 
strings have been pre-processed with the *CytoGPS* package into 
binary vectors. For the sake of clarity and efficiency, we have chosen a subset of patients and features for this example.
```{r data}
setwd("C:/Cat/01KRCLab/SVN/thresher/pkg/Mercator/vignettes") #for the time being
my.data <- read.csv("Mercator_Test_Data.csv", header=TRUE)
dim(my.data)
```

### Generating the BinaryMatrix
The functions of the Mercator package operate on the BinaryMatrix S4 object, 
which forms the input of the subsequent functions and visualizations. 

The BinaryMatrix object is formed from a matrix of integer or numeric 
class. Although this package is designed for the processing and visualizations of
binary data, the BinaryMatrix object and subsequent functions accept a variety 
of integer and numeric values. 

Row and column names can be assigned as data frames.
If no row or column headings are assigned, the BinaryMatrix takes the row and 
column names of the inital matrix as default. Here, we wish to keep the 
column names associated with the parent matrix, but must create row names 
to build the BinaryMatrix. 

Notice also that the object always includes a "history" element that tracks how it has been processed.
```{r}
my.data <- as.matrix(my.data)
my.rows <- c(1:length(my.data[,1]))
my.rows <- paste("C", my.rows, sep = "")
my.rows <- data.frame(my.rows)
my.binmat <- BinaryMatrix(my.data, , my.rows)
summary(my.binmat)
```

We wish to cluster the whole karyotypes of each patient to identify the 
patterns of important chromosomal abnormalities that link them. To proceed, 
we must transpose the BinaryMatrix. Transposition meaningfully transposes
the row and column headings of the BinaryMatrix, as well.
```{r}
my.binmat <- t(my.binmat)
summary(my.binmat)
```

### Remove Duplicate Features
The binary feature-vectors (viewed across a population of patient
samples) are rarely unique. 
Having identical feature vectors can complicate some of the
clustering and visualization routines that we want to use (often by
introducing a division by zero). But they can also alter the
biological implications, by automatically giving more "weight" to a
single genomic event (like a trisomy or monosomy). To deal with this
issue, the *Mercator* package includes a function to remove
duplicate or redundant features.
```{r duplicateFeatures}
my.binmat <- removeDuplicateFeatures(my.binmat)
summary(my.binmat)
```

In the case of our data, only 136 of the 740 karyotypes are unique. 
Some of the karyotypes are "not used", in the sense that they contain 
none of the abnormalities selected for this limited subset.
```{r}
length(my.binmat@info$notUsed)
```

By contrast, many features are *used* but are simply redundant.
```{r}
length(my.binmat@info$redundant)
```

# Data Filtering with the Thresher Method
*
*Mercator* implements the functions of the *Thresher* R package, including 
outlier detection, principal component analysis, the von Mises Fisher
mixture method, and the Auer-Gervini statistic to identify and reduce to 
only informative features for clustering. [Wang et al]
The underlying idea is that the features can be viewed as
"weight vectors" in a principal component space trying to display the samples.
The lengths of the vectors are a measure of their importance in the data set;
short vectors can (and probably should) be removed since they do not carry
much useful information. We have incorporated that feature into the
*Mercator*  package.

We create a *ThreshedBinaryMatrix* to implement the algorithm. 
In general, a delta cutoff above approximately 0.3 can be chosen as standard to 
indicate informative feature. Then, we subset our ThreshedBinaryMatrix 
to only include features above our given cutoff.
```{r thresher}
set.seed(21348)
my.binmat <- threshLGF(my.binmat, cutoff=0.3)
summary(my.binmat)
```

The red vertical line in the figure indicates the cutoff we have chosen 
to separate uninformative features (<0.3) from informative ones (>0.3).
```{r delta, fig.cap="Histogram of weight vectors."}
Delta <- my.binmat@thresher@delta
hist(Delta, breaks=20, main="", xlab="Weight")
abline(v=0.3, col='red')
```

We implement the *Reaper* functionality of *Thresher* for principal 
component analysis. Principal components returned numerically...
```{r pcdim}
my.binmat@reaper@pcdim
my.binmat@reaper@nGroups
```

... or they can be visualized with an *Auer-Gervini plot*... 
```{r pcVis-1, fig.cap="Auer-Gervini plot.}
plot(my.binmat@thresher@ag)
abline(h=my.binmat@reaper@pcdim, col="blue")
abline(h=my.binmat@reaper@nGroups, col="green")
abline(h=8, col="orange")
```

```{r pcVis-2, fig.cap="Scree plot.}
screeplot(my.binmat@thresher)
abline(h=my.binmat@reaper@pcdim, col="blue")
abline(h=my.binmat@reaper@nGroups, col="green")
abline(h=8, col="orange")
```

All three of these methods provide different, but imperfect, means of 
estimating K. The blue line represents the result of the *pcdim* 
calculation of principal components. The green line represents the result 
of the nGroups calculation. The orange line represents an estimate of 
principal components from visual inspection.

From inspection of the plots, we determine an appropriate 
K with which to proceed as 8.
```{r kk}
kk <- 8
```

# Selecting a Distance Metric
The Mercator package implements 10 distance metrics: Jaccard, Sokal-Michener, Hamming, Russell-Rao, Pearson, Goodman-Kruskal, Manhattan, Canberra, Binary 
and Euclidean. Although some of these metrics 
can be used for continuous or categorical data, all are appropriate for 
some or all binary matrices. Mercator allows the user to easily select 
the most appropriate metric to represent similarity and difference in a 
biologically meaningful way within a given dataset.

Here, we will proceed with the Jaccard distance, because of its ease of 
interpretability, commoness of use, and its appropriatness of application 
to asymmetric binary data, such as the binary vector output of CytoGPS 
in this dataset.

# Visualizing with 5 Methods
The Mercator Package allows visualization of data with 5 methods, including both 
standard techniques (hierarchical clustering, heat maps) and large-scale 
multi-dimensional visualizations (multidimensional scaling (MDS), 
T-distributed Stochastic Neighbor Embedding (t-SNE), and iGraph.) 

The initial Mercator function can be implemented with any visualization, 
and visualizations can be added in an arbitrary order.
```{r distance, echo=TRUE}
jacc.Vis <- Mercator(my.binmat, "jaccard", "hclust", K=kk)
```

We can represent all the distances between features within the 
dissimilarity matrix we have calculated on our data as a 
histogram, as a visual representation of relatedness. 
```{r jacc-hist}
hist(jacc.Vis, 
     xlab="Jaccard Distance", main="Histogram of Distances")
```

Mercator allows us to implement common, standard visualizations 
such as hierarchical clustering...
```{r jacc-hclust}
plot(jacc.Vis@view[[1]], col="black", pch=jacc.Vis@symv)
```

... and heat map.
```{r jacc-heat}
jacc.Vis <- addVisualization(jacc.Vis, "heat")
plot(jacc.Vis@view[[2]], col=jacc.Vis@colv, pch=jacc.Vis@symv)
```

Mercator can be used to plot t-Stochastic Neighbor Embedding 
(t-SNE) plots for visualizing large-scale, high-dimensional data in 
2-dimensional space. 
```{r jacc-tsne5}
par(pty="s")
jacc.Vis <- addVisualization(jacc.Vis, "tsne", 
            perplexity=5, 
            xlab="T1", ylab="T2")
plot(jacc.Vis@view[[3]]$Y, col=jacc.Vis@colv, pch=jacc.Vis@symv,
     main="t-SNE; Jaccard Distance; perplexity=5")
```

t-SNE parameters, such as perplexity, can be used to fine-tune 
the plot as the visualization is created. Using addVisualization 
to create a new, tuned plot of an existing type overwrites the 
existing plot of that type.
```{r jacc-tsne10}
jacc.Vis <- addVisualization(jacc.Vis, "tsne", 
            perplexity=10,
            xlab="T1", ylab="T2")
plot(jacc.Vis@view[[3]]$Y, col=jacc.Vis@colv, pch=jacc.Vis@symv,
     main="t-SNE; Jaccard Distance; perplexity=10")
par(pty="m")
```

Mercator allows visualization of multi-dimensional scaling (MDS) plots, as well.
```{r jacc-mds1}
jacc.Vis <- addVisualization(jacc.Vis, "mds")
plot(jacc.Vis@view[[4]], col=jacc.Vis@colv, pch=jacc.Vis@symv,
      main="MDS; Jaccard Distance", xlab="PC1", ylab="PC2")
```

### IGraph
Mercator can be used to visualize complex networks using 
IGraph. To improve clarity of the visualization and computational 
time, we implement the downsample function to reduce the 
number of data points to be linked and visualized. 
The idea goes back to Peng Qiu's implementation of the
SPADE clustering algorithm for mass cytyometry data. The main point is to *under* sample
the densest regions of the data space to make it more likely that rarer clusters
will still be adequately sampled.

**Note:** The *Mercator* class includes a "subset" operator that tries to preserve
earlier visualizations. This operator is fast for MDS or t-SNE models, but
is very slow for large hierarchical clustering. (It uses the implementation in the *dendextend*
package, which works by removing a single leaf at a time from the tree.) In the
next code chunk, we first throw away the dendrogram, then subset using the downsampled
data, and then compute a new dendrogram.
```{r downsample}
X <- jacc.Vis
N <- as.matrix(X@distance)
set.seed(87530)
P <- downsample(40, N, 0.1)
J <- jacc.Vis[P]
J <- addVisualization(J, "tsne", perplexity=5)
plot(J@view[[3]]$Y, col=J@colv, pch=J@symv, main="Down-sampled t-SNE Plot",
     xlab="T1", ylab="T2")
```
The densest "eyes" are heavily under-sampled.

Now we can look at the resulting graph, using three different "layouts".
BECAUSE OF A BUG IN IGRAPH, I DON'T WORK!
```{r igraph}
set.seed(10967)
J <- addVisualization(J, "mds")
J <- addVisualization(J, "graph")
G <- J@view[["graph"]]

V <- igraph::vertex_attr(G$graph)

plot(G$graph, layout=G$layouts[["mds"]])

plot(G$graph, layout=G$layouts[["nicely"]], 
     main="Graphical View of Down-sampled Jaccard Distance Matrix",
     xlim=c(-1,1))


plot(G$graph, layout=G$layouts[["tsne"]], main="T-SNE Layout")
```

#Cluster Identities and Color Tuning
getClusters(my.vis) #gives color and cluster number
recolor
remapColors

```{r}
my.clust <- getClusters(jacc.Vis)

```
Color of cluster 1
Identities in cluster 3

||||||| .r125

```{r}
my.vis <- addVisualization(my.vis, "mds")
plot(my.vis@view[[3]], col=my.vis@colv, pch=my.vis@symv)
my.clust <- recoverCluster(my.vis)
remapColors()
=======

```{r}
my.vis <- addVisualization(my.vis, "mds")
plot(my.vis@view[[3]], col=my.vis@colv, pch=my.vis@symv)
my.clust <- getClusters(my.vis)
remapColors()
>>>>>>> .r132
```