---
title: "Mercator Vignette"
author: "Cat Coombes"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: yeti
    highlight: kate
    toc: true
editor_options: 
  chunk_output_type: console
---

%\VignetteIndexEntry{Mercator}
%\VignetteKeywords{clustering,visualization,distance metric,dissimilarity matrix,distance,dissimilarity,multidimensional scaling,tSNE,hierarchical clustering,iGraph,heat map}
%\VignetteDepends{Mercator}
%\VignettePackage{Mercator}
\documentclass[11pt]{article}
\usepackage{authblk}
\usepackage{url}

%\usepackage{stats}
%\usepackage{utils}
%\usepackage{cluster}
%\usepackage{Rtsne}
%\usepackage{Polychrome}
%\usepackage{Thresher}
%\usepackage{dendextend}
%\usepackage{igraph}
%\usepackage[oompaBase}
%\pagestyle{myheadings}

\setlength\parindent{0pt}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8in}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\parskip}{0.37em}%

\newcommand{\quotes}[1]{``#1''}
\def\rcode#1{\texttt{#1}}
\def\fref#1{\textbf{Figure~\ref{#1}}}
\def\tref#1{\textbf{Table~\ref{#1}}}
\def\sref#1{\textbf{Section~\ref{#1}}}

\title{Using the Mercator Package}
\date{\today}
\author[1]{Zachary B. Abrams}
\author[2]{Caitlin E. Coombes}
\author[3]{Suli Li}
\author[4]{Kevin R. Coombes}
\affil[1]{Dept. of Biomedical Informatics\\ The Ohio State University}
\affil[2]{Dept. of Biomedical Informatics\\ The Ohio State University}
\affil[3]{Dept. of Leukemia\\ The University of Texas MD Anderson Cancer Center}
\affil[4]{Dept. of Biomedical Informatics\\ The Ohio State University}

\begin{document}
\maketitle
\tableofcontents

\section{Implementation in of an Example Dataset Mercator}
\label{Implementation}

\subsubsection{The BinaryMatrix Object Class}
\label{BinaryMatrix}

First we load the R library package \texttt{Mercator}.
```{r library}
library(Mercator)
```

We proceed with a model dataset of karyotypes from patients with [CANCER] 
with $XXX$ karyotypic features recorded over $XXX$ patients from the public
Mitelman database. Cytogenetic abnormalities, recorded in Mitelman as text 
strings have been pre-processed with the \texttt{CytoGPS} package into 
binary vectors.

For the sake of clarity and efficiency, we have chosen a subset of patients 
and features for this example.
```{r data}
setwd("C:/Users/catco/Dropbox/CatCLLStudy/Mercator paper") #yes, I know this is a problem and needs to be fixed. I'd love an explanantion as to how.
my.data <- read.csv("Mercator_Test_Data.csv", header=TRUE)
dim(my.data)
```

The functions of the Mercator package operate on the BinaryMatrix S4 object. 
The BinaryMatrix object is formed from a matrix of integer or numeric 
class, and row and column headings can be assigned as data.frames. If no 
row or column headings are assigned, the BinaryMatrix takes the row and 
column names of the inital matrix as default. Here, we wish to keep the 
column names associated with the parent matrix, but must create row names 
to build the BinaryMatrix.
```{r}
my.data <- as.matrix(my.data)
my.rows <- c(1:length(my.data[,1]))
my.rows <- data.frame(my.rows)
my.binmat <- BinaryMatrix(my.data, , my.rows)
summary(my.binmat)
```

We wish to cluster the whole karyotypes of each patient to identify the 
patterns of important chromosomal abnormalities that link them. To proceed, 
we must transpose the BinaryMatrix. Transposition meaningfully transposes
the row and column headings of the BinaryMatrix, as well.
```{r}
my.binmat <- t(my.binmat)
summary(my.binmat)
```

Next, we remove duplicate features from the BinaryMatrix. Removal of duplicates 
is recorded in the BinaryMatrix's history.
```{r duplicateFeatures}
my.binmat <- removeDuplicateFeatures(my.binmat)
summary(my.binmat)
```

\subsubsection{Filtering with the Thresher Method}
\label{Thresher}

\quotes{Mercator} implements the functions of the \quotes{Thresher} package, including 
outlier detection, principal component analysis, the von Mises Fisher
mixture method, and the Auer-Gervini statistic to identify and reduce to 
only informative features for clustering.

We create a \quotes{ThreshedBinaryMatrix} to implement the algorithm. 
In general, a delta cutoff above 0.3 can be chosen as standard to 
indicate informative feature. Then, we subset our ThreshedBinaryMatrix 
to only include features above our given cutoff.
```{r thresher}
my.binmat <- threshLGF(my.binmat) #create a ThreshedBinaryMatrix
Delta <- my.binmat@thresher@delta
hist(Delta, breaks=15, main="", xlab="Weight")
abline(v=0.3, col='red')
my.binmat <- threshLGF(my.binmat, cutoff = 0.3)
summary(my.binmat)
```

We implement the \quotes{Reaper} functionality of \quotes{Thresher} for principal 
component analysis. Principal components returned numerically...
```{r pcdim}
my.binmat@reaper@pcdim
my.binmat@reaper@nGroups
```

... or they can be visualized with an \quotes{Auer-Gervini plot} or 
\quotes{screeplot}.
```{r pcVis}
plot(my.binmat@thresher@ag)
abline(h=my.binmat@reaper@pcdim, col="blue")
abline(h=my.binmat@reaper@nGroups, col="green")
abline(h=8, col="orange")
screeplot(my.binmat@thresher)
abline(h=my.binmat@reaper@pcdim, col="blue")
abline(h=my.binmat@reaper@nGroups, col="green")
abline(h=8, col="orange")
```

All three of these methods provide different, but imperfect, means of 
estimating K. From inspection of the plots, we determine an appropriate 
K with which to proceed as $8$.
```{r}
k <- 8
```

\subsubsection{Selecting a Distance Metric}
\label{Distance}

The Mercator package implements 10 distance metrics: Jaccard, Sokal-Michener, Hamming, 
Russell-Rao, Pearson, Goodman-Kruskal, Manhattan, Canberra, Binary 
and Euclidean. Although some of these metrics 
can be used for continuous or categorical data, all are appropriate for 
some or all binary matrices. Mercator allows the user to easily select 
the most appropriate metric to represent similarity and difference in a 
biologically meaningful way within a given dataset.

Here, we will proceed with the Jaccard distance, because of its ease of 
interpretability, commoness of use, and its appropriatness of application 
to asymmetric binary data, such as the binary vector output of CytoGPS 
in this dataset.

\subsubsection{Visualizing with 5 Methods}
\label{Visualization}

The Mercator Package allows visualization of data with 5 methods, including both 
standard techniques (hierarchical clustering, heat maps) and large-scale 
multi-dimensional visualizations (multidimensional scaling (MDS), 
T-distributed Stochastic Neighbor Embedding (t-SNE), and iGraph.) 

The initial Mercator function can be implemented with any visualization, 
and visualizations can be added in an arbitrary order.
```{r distance, echo=TRUE}
my.vis <- Mercator(my.binmat, "jaccard", "hclust", K=k)
```

We can represent all the distances between features within the 
dissimilarity matrix we have calculated on our data as a 
histogram, as a visual representation of relatedness. 
```{r}
hist(my.vis, 
     xlab="Jaccard Distance", main="Histogram of Distances")
```

Mercator allows us to implement common, standard visualizations 
such as hierarchical clustering...
```{r}
plot(my.vis@view[[1]], col=my.vis@colv, pch=my.vis@symv)
```

... and heat map.
```{r}
my.vis <- addVisualization(my.vis, "heat")
plot(my.vis@view[[2]], col=my.vis@colv, pch=my.vis@symv)
```

Mercator can be used to plot t-Stochastic Neighbor Embedding 
(t-SNE) plots for visualizing large-scale, high-dimensional data in 
2-dimensional space. 
```{r}
my.vis <- addVisualization(my.vis, "tsne", 
                          perplexity=5)
plot(my.vis@view[[3]]$Y, col=my.vis@colv, pch=my.vis@symv,
     main="t-SNE; perplexity=5")
```

t-SNE parameters, such as perplexity, can be used to fine-tune 
the plot as the visualization is created. Using addVisualization 
to create a new, tuned plot of an existing type overwrites the 
existing plot of that type.
```{r}
my.vis <- addVisualization(my.vis, "tsne", 
                           perplexity=10)
plot(my.vis@view[[3]]$Y, col=my.vis@colv, pch=my.vis@symv,
     main="t-SNE; perplexity=10")
```


```{r}
my.vis <- addVisualization(my.vis, "mds")
plot(my.vis@view[[3]], col=my.vis@colv, pch=my.vis@symv)
my.clust <- getClusters(my.vis)
remapColors()
```

Mercator can be used to visualized complex networks using 
iGraph. To improve clarity of the visualization and computational 
time, we implement the downsample function to reduce the 
number of data points to be linked and visualized. 
```{r}
my.sample <- downsample(my.vis, "jaccard", 1)
downsample(my.sample, my.vis, .5)


my.vis <- addVisualization(downsample(my.vis, "jaccard"), "graph")
plot(my.vis@view[[5]], col=my.vis@colv, pch=my.vis@symv)
```


COLOR TUNING
By default, the color of the cluster dendrogram is implemented 
as the default color of the first cluster.



getClusters(my.vis) #gives color and cluster number
recolor
remapColors







```{r}
jacF <- Mercator(ft, "jaccard", "mds", K=Kf)
jacF <- addVisualization(jacF, "hclust")
jacF <- addVisualization(jacF, "tsne")
plot(jacF@view[[1]], col=jacF@colv, pch=jacF@symv)
plot(jacF@view[[2]], col=jacF@colv, pch=jacF@symv)
plot(jacF@view[[3]]$Y, col=jacF@colv, pch=jacF@symv)
```






























# Get some datata
```{r load.matrix}
setwd("C:/Users/catco/Dropbox/KRC Lab Box/Mercator AML/datata/")
#readLines("AML Cat.csv", n=1) #I legit do not know what this fixed it. But there you have it.
aml.df <- read.csv("AML Cat.csv", header=TRUE)
dim(aml.df)

head(aml.df[c(1:20), c(2747:2751)])
aml.df$X <- NULL
aml.df$X.1 <- NULL
aml.df$X.2 <- NULL
dim(aml.df)
head(aml.df[c(1:20), c(2744:2748)])
```

Make it a matrix
```{r}
aml.mt <- as.matrix(aml.df)
dim(aml.mt)
class(aml.mt)
class(aml.mt[1,1])
```

## Test Subset
In order to more efficiently test the code, create a small data subset.
```{r tiny, eval=FALSE}
aml.mt <- aml.mt[c(1:1000),c(1:1000)]
dim(aml.mt)
```

## Make a Binary Matrix

Load the Mercator package and its dependents, if you haven't already.
```{r}
#install.packages("Mercator", repos="http://R-Forge.R-project.org")
library(Mercator)
suppressWarnings( suppressMessages( library(Thresher) ))
```

# By Feature
I didn't know if you wanted this clustered by patient or by feature, so I did both.

Identify any columns that are all 0s and remove them, since they break Thresher.
```{r no0sft}
ft <- aml.mt
dim(ft)

zeros <- apply(ft, 2, sum)
length(zeros[zeros == 0])

ft <- ft[,apply(ft, 2, sum)!=0]

dim(ft)
```

Make it a BinaryMatrix.
```{r ftbm}
#rownames(aml.mt)
#It needs row names.
aml.row <- c(1:length(ft[,1]))
rownames(ft) <- aml.row
#rownames(aml.mt)

ft <- BinaryMatrix(ft)
summary(ft)
```

Remove duplicate features.
```{r nodupsft}
dim(ft)
ft <- removeDuplicateFeatures(ft)
summary(ft)
```

Next we Thresh, and identify uninformative features (defined by delta < 0.3). I can't figure out how to remove them, so I'm just going to keep going.
```{r threshft}
set.seed(1987)
ft <- threshLGF(ft)
summary(ft)

Delta <- ft@thresher@delta
#sort(Delta)
hist(Delta, breaks=15, main="", xlab="Weight")
abline(v=0.3, col='red')

abandon <- ft@thresher@delta < 0.3
names(abandon)[abandon]

summary(ft)
```

We identify our dimensions/principal components numerically and visually, and arbitrarily set k to keep things easy.
```{r}
th <- ft@thresher
re <- ft@reaper

re@pcdim
re@nGroups

#makeFigures(th)
#par(ask = FALSE) # resets makeFigures

plot(th@ag)
abline(h=re@pcdim, col="green", lty="longdash")
abline(h=re@nGroups, col="blue", lty ="longdash")

screeplot(th)
abline(v=re@pcdim, col="green")
abline(v=re@nGroups, col="blue")

Kf <- re@nGroups
```

There are a variety of distance metrics at our disposal, but we're going to go easy and just use Jaccard.
```{r}
all.metrics <- c("jaccard", "sokalMichener", "hamming", "russellRao", "pearson", "goodmanKruskal", "manhattan", "canberra", "binary", "euclid")
```

If I were trying, this is where I would cluster distance metrics to determine the best one and calculate silhouette width, but I'm not.

###Using the Jaccard distance, we cluster by patient and characterize.

To determine the defining features of each cluster, we begin by computing the frequency of each sign, symptom, or clinical test result in each of the 10 sample clusters.
```{r}
jacF <- Mercator(ft, "jaccard", "mds", K=Kf)
jC <- getClusters(jacF)

relFrequency <- sapply(1:Kf, function(i) { #reset K here
  M <- ft@binmat[, jC == i]
  apply(M, 1, mean)
})
relFrequency <- 100*relFrequency

dim(relFrequency)
summary(relFrequency)
```

Next, we look at the maximum frequency for each clinical features, where a large value suggests that the abnormality may aid in "characterizing" at least one of the sample clusters.
```{r}
M1 <- apply(relFrequency, 1, max) #find the max value in each row, where each row is a feature
opar <- par(mfrow = c(1,2))
plot(M1, xlab="Feature", ylab="Percentage")
abline(h=c(15,50,75), col="green")
plot(sort(M1), ylab="Percentage")
abline(h=c(15,50,75), col="green")
par(opar)
```

We view the characteristics of each cluster in table form.
```{r}
if (!require("DT")) {
  install.packages("DT")
  library("DT")
}

if (!require("reshape2")) {
  install.packages("reshape2")
  library("reshape2")
}

if (!require("Polychrome")) {
  install.packages("Polychrome")
  library("Polychrome")
}

stack <- melt(relFrequency)
colnames(stack) <- c("Feature", "Cluster", "Percent")
stack <- stack[, c(2, 1, 3)]
summary(stack)

w <- which(tapply(stack$Percent, list(stack$Cluster), max) < 75)
if (length(w) == 0) w <- 0

pickME <- stack$Percent > 75 | ((stack$Cluster %in% w) & stack$Percent > 50 )
partStack <- stack[pickME,]
partStack$Percent <- round(partStack$Percent, 1)

dk <- Polychrome::dark.colors(Kf)

datatable(partStack, rownames=FALSE) %>% 
  formatStyle('Cluster', backgroundColor = styleEqual(seq(1:Kf), dk), color="white",
              fontWeight="bold")
```

Make some pictures.
```{r}
jacF <- Mercator(ft, "jaccard", "mds", K=Kf)
jacF <- addVisualization(jacF, "hclust")
jacF <- addVisualization(jacF, "tsne")
plot(jacF@view[[1]], col=jacF@colv, pch=jacF@symv)
plot(jacF@view[[2]], col=jacF@colv, pch=jacF@symv)
plot(jacF@view[[3]]$Y, col=jacF@colv, pch=jacF@symv)
```




# By Patient

First, transpose.
```{r t}
pt <- t(aml.mt)
dim(pt)
```

Identify any columns that are all 0s and remove them, since they break Thresher.
```{r no0spt}
zeros <- apply(pt, 2, sum)
length(zeros[zeros == 0])

pt <- pt[,apply(pt, 2, sum)!=0]

dim(pt)
```

Make it a BinaryMatrix.
```{r ptbm}
rownames(pt)[c(1:15)]
colnames(pt)[c(1:15)]
#It needs column names.
pt.col <- c(1:length(pt[1,]))
colnames(pt) <- pt.col
colnames(pt)[c(1:15)]

pt <- BinaryMatrix(pt)
summary(pt)
```

Remove duplicate features.
```{r nodupspt}
dim(pt)
pt <- removeDuplicateFeatures(pt)
summary(pt)
```

Next we Thresh, and identify uninformative features (defined by delta < 0.3). I can't figure out how to remove them, so I'm just going to keep going.
```{r threshpt}
set.seed(1987)
pt <- threshLGF(pt)
summary(pt)

Delta <- pt@thresher@delta
#sort(Delta)
hist(Delta, breaks=15, main="", xlab="Weight")
abline(v=0.3, col='red')

abandon <- pt@thresher@delta < 0.3
names(abandon)[abandon]

summary(pt)
```

We identify our dimensions/principal components numerically and visually, and arbitrarily set k to keep things easy.
```{r}
th <- pt@thresher
re <- pt@reaper

re@pcdim
re@nGroups

#makeFigures(th)
#par(ask = FALSE) # resets makeFigures

plot(th@ag)
abline(h=re@pcdim, col="green", lty="longdash")
abline(h=re@nGroups, col="blue", lty ="longdash")

screeplot(th)
abline(v=re@pcdim, col="green")
abline(v=re@nGroups, col="blue")

Kp <- re@nGroups
```

If I were trying, this is where I would cluster distance metrics to determine the best one and calculate silhouette width, but I'm not.

###Using the Jaccard distance, we cluster by patient and characterize.

To determine the defining features of each cluster, we begin by computing the frequency of each sign, symptom, or clinical test result in each of the 10 sample clusters.
```{r}
jacP <- Mercator(pt, "jaccard", "mds", K=Kp)
jC <- getClusters(jacP)

relFrequency <- sapply(1:Kp, function(i) { #reset K here
  M <- pt@binmat[, jC == i]
  apply(M, 1, mean)
})
relFrequency <- 100*relFrequency

dim(relFrequency)
summary(relFrequency)
```

Next, we look at the maximum frequency for each clinical features, where a large value suggests that the abnormality may aid in "characterizing" at least one of the sample clusters.
```{r}
M1 <- apply(relFrequency, 1, max) #find the max value in each row, where each row is a feature
opar <- par(mfrow = c(1,2))
plot(M1, xlab="Feature", ylab="Percentage")
abline(h=c(15,50,75), col="green")
plot(sort(M1), ylab="Percentage")
abline(h=c(15,50,75), col="green")
par(opar)
```

We view the characteristics of each cluster in table form.
```{r}
if (!require("DT")) {
  install.packages("DT")
  library("DT")
}

if (!require("reshape2")) {
  install.packages("reshape2")
  library("reshape2")
}

if (!require("Polychrome")) {
  install.packages("Polychrome")
  library("Polychrome")
}

stack <- melt(relFrequency)
colnames(stack) <- c("Feature", "Cluster", "Percent")
stack <- stack[, c(2, 1, 3)]
summary(stack)

w <- which(tapply(stack$Percent, list(stack$Cluster), max) < 75)
if (length(w) == 0) w <- 0

pickME <- stack$Percent > 75 | ((stack$Cluster %in% w) & stack$Percent > 50 )
partStack <- stack[pickME,]
partStack$Percent <- round(partStack$Percent, 1)

dk <- Polychrome::dark.colors(Kp)

datatable(partStack, rownames=FALSE) %>% 
  formatStyle('Cluster', backgroundColor = styleEqual(seq(1:Kp), dk), color="white",
              fontWeight="bold")
```

Make some pictures.
```{r}
jacP <- Mercator(pt, "jaccard", "mds", K=Kp)
jacP <- addVisualization(jacP, "hclust")
jacP <- addVisualization(jacP, "tsne")
plot(jacP@view[[1]], col=jacP@colv, pch=jacP@symv)
plot(jacP@view[[2]], col=jacP@colv, pch=jacP@symv)
plot(jacP@view[[3]]$Y, col=jacP@colv, pch=jacP@symv)
```







