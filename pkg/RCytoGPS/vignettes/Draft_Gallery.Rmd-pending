---
title: "RCytoGPS Gallery"
author: "Dwayne Tally, Zacahary B. Abrams, and Kevin R. Coombes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RCytoGPS Gallery}
  %\VignetteKeywords{OOMPA,CytoGPS,karyotypes,idiograms,graphics}
  %\VignetteDepends{RCytoGPS}
  %\VignettePackage{RCytoGPS}
  %\VignetteEngine{knitr::rmarkdown}
---


```{r opts, echo=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=5)
```
# Introduction
This is the supplementary vignette for RCytoGPS and will primarily focus on the different visuals you can generate from the data sets by changing the arguements for image(). The results of the visuals will be based off one data set, but images can accept data from multiple data sets. Also the data being used to generate the visuals will be the same data set from the main vignette.

## Setup
First, you need to load the necassary library to extract data from JSON files.
```{r Setup}
library(RCytoGPS)
```
```{r eval=FALSE,echo=FALSE}
library(rjson)
#Idioformat has the additional values needed that is not obtained from readLGF
load("Idioformat.rda")
rnames <- function(lst, item) {
  f <- function(ll, inds) {
    if ((ii <- match(item, names(ll), FALSE)))
      list(inds=c(inds, ii), len=length(ll[[ii]]))
    else if (all(is.atomic(unlist(ll, FALSE))) || !is.list(ll))
      NULL
    else
      lapply(seq_along(ll), function(i) f(ll[[i]], inds=c(inds, i)))
  }
  unlist(f(lst, NULL))
}

## Make up sample names that include row number, padded with leading zeros
padnames <- function(prefix, values, ndigits = NULL) {
  M <- max(values)
  if (is.null(ndigits)) {
    ndigits <- trunc(log10(M))
  }
  padlength <- sapply(values, function(n) sum(n < 10^(1:ndigits)))
  pad <- sapply(padlength, function(p) paste(rep("0", p),collapse = ""))
  paste(prefix, pad, values, sep="")
}


extractOneLGF <- function(J) {
  bands <- J$iscn2016_bands # cytoband labels/names
  ## extract the status
  OUT <- J$output
  KY <- matrix(NA, ncol = 2, nrow = length(OUT))
  colnames(KY) <- c("Status", "Karyotype")
  for (I in 1:length(OUT)) {
    x <- OUT[[I]]
    kary <- x$karyotype
    stat <- x$status
    KY[I,] <- c(stat, kary)
  }
  KY <- as.data.frame(KY, stringsAsFactors = FALSE)
  rownames(KY) <- padnames("RN", 1:length(OUT))
  KY$Status  <- factor(KY$Status)
  
  ## extract the (sub)clone ids
  clone <- unlist(lapply(OUT, function(x){
    if((x$status) %in% c("Success", "Fixable grammar error and success")) {
      1:length(lapply(x$parsing_result, "[[", "loss_gain_fusion_computing"))
    }
  }))
  ## extract the binary-mapped LGF data
  lgf <- lapply(OUT, function(x) { # Get the loss data from parsing_result
    if((x$status) %in% c("Success", "Fixable grammar error and success")) {
      lgf <- lapply(x$parsing_result, "[[","loss_gain_fusion_computing")
    }
  })
  ## compute row-name IDS
  df.ID <- as.data.frame(matrix(rnames(lgf, "loss"), ncol = 4, byrow = TRUE))
  id <- df.ID$V1
  if(any(df.ID$V2 != clone)) {
    warning("Disagreement among clone IDs.")
  }
  
  fullID <- apply(df.ID[, 1:3], 1, paste, collapse=".")
  if (any(duplicated(fullID))) {
    warning("Duplicated identifiers should not happen.")
  }
  ## Extract the loss, gain, and fusion binary data separately
  loss1 <- sapply(lgf, function(x){
    lapply(x, "[[","loss")
  })
  df_Loss <- as.data.frame(matrix(unlist(loss1), ncol = 916, byrow = TRUE),
                           stringsAsFactors = FALSE)
  colnames(df_Loss) <- paste("Loss", bands, sep = "_")
  
  gain1 <- sapply(lgf, function(x){
    lapply(x, "[[","gain")
  })
  df_Gain <- as.data.frame(matrix(unlist(gain1), ncol = 916, byrow = TRUE),
                           stringsAsFactors = FALSE)
  colnames(df_Gain) <- paste("Gain", bands, sep = "_")
  fusion1 <- sapply(lgf, function(x){
    lapply(x, "[[","fusion")
  })
  df_Fusion <- as.data.frame(matrix(unlist(fusion1), ncol = 916, byrow = TRUE),
                             stringsAsFactors = FALSE)
  colnames(df_Fusion) <- paste("Fusion", bands, sep = "_")
  ## Put them back together
  df.lgf <- cbind(df_Loss, df_Gain, df_Fusion)
  rownames(df.lgf) <- fullID
  df.lgf$ID = id
  df.lgf$Clones = clone
  w <- which(colnames(df.lgf) == "ID")
  df.lgf <- df.lgf[, c(w:(w + 1), 1:(w-1))]  
  cytoData <- Idioformat(df.lgf)
  rownames(cytoData) <- cband
  
  list(Status = KY, LGF = df.lgf, cytoData = cytoData)
}

readLGF <- function(files = NULL, folder = NULL) {
  ## Figure out which files we want to read
  if (is.null(folder)) {
    folder  <-  "."
  }
  if (is.null(files)) {
    files  <- list.files(folder, pattern = "*.json", full.names = TRUE) # character vector , one file per entry
  }
  if (length(files) < 1) {
    stop("No JSON input files to read.")
  }
  message("Reading ", length(files), " file(s) from '", folder, "'.\n")
  
  ## make sure that, when done,  we leave the working directory in the same state that we found it.
  home <- getwd()
  on.exit(setwd(home))
  setwd(folder)
  
  ## It might get large -- not said by Davis Guggenheim
  myJSON <- lapply(files, function(x) fromJSON(file = x)) # a list, one element per JSON file
  temp  <- lapply(myJSON, extractOneLGF)
  temp
}



Idioformat <- function(df){
  #element name will be the same as karyotype
  #first example loss.1, loss.2
  Chromosome <- Chromosome
  loc.start <- loc.start
  loc.end <- loc.end
  arm <- arm
  Band <- band
  #row.names(df) <- cband
  Loss <- df[, grepl("Loss", names(df))]
  Gain <- df[, grepl("Gain", names(df))]
  Fusion <- df[, grepl("Fusion", names(df))]
  
  
  data.frame(Chromosome = Chromosome, 
                    loc.start = loc.start,
                    loc.end = loc.end,
                    arm = arm,
                    Band = Band, 
                    Loss = colSums(Loss), Gain = colSums(Gain), Fusion = colSums(Fusion))
  #row.names(df) <- cband
  
}
```

# Extracting JSON IdioData
```{r Extracting JSON data and formating to LGF model}
wd <- ("C:/Users/firem/Documents/input_outputDirectory")
temp <- readLGF(folder = wd)

cytoData <- lapply(temp, function(x){
  return(x$cytoData)
})
cytoData <- data.frame(cytoData)

cytoData[,9:13] <- NULL

colnames(cytoData)[which(names(cytoData) == "Loss")] <- "A.Loss"
colnames(cytoData)[which(names(cytoData) == "Gain")] <- "A.Gain"
colnames(cytoData)[which(names(cytoData) == "Fusion")] <- "A.Fusion"
colnames(cytoData)[which(names(cytoData) == "Loss.1")] <- "B.Loss"
colnames(cytoData)[which(names(cytoData) == "Gain.1")] <- "B.Gain"
colnames(cytoData)[which(names(cytoData) == "Fusion.1")] <- "B.Fusion"


```

# Function to retrieve the dataset and convert
data retrieves the dataset that this vignette will be using from the library RCytoGPS and converts it into a S4 object. The S4 object will contain the dataframe that image will use the columns and create the different visuals. 

```{r}
bandData <- CytobandData(cytoData)
```

# Plotting Cytoband Data Along the Genome
The first visual is a barplot to show the frequencies of the cytogenetic event mapped to the assoicated chromosome. The parameters for barplot is the dataset, the specific column you want to graph, and the color of the graph.
```{r gb, fig.cap="Cytoband level data along the genome.", fig.width=10, fig.height=5}
opar <- par(mfrow=c(2,1))
barplot(bandData, "A.Loss", col = "forestgreen")
barplot(bandData, "A.Gain", col="orange")
par(opar)
```

# Single Chromosome Plots
Note: "Horizontal" and "vertical" refer to the direction of the chromosome with its cytoband shading.

## Plotting Cytoband-Level Data Along One Chromosome

The first visualization you can make with image is a 'vertical stacked chromosome' which allows you to see a vertical barplot and its associated chromosome on the y axis, this allows you to see multiple cytogenetic events on a specified chromosome. The parameters to produce this image is the dataset, the cyotgenetic event, and a specific chromosome.

Note: unless specified horiz is set to FALSE by default.
```{r v.plot2Chrom, fig.width=8, fig.height=5,fig.cap = "Vertical stacked barplot of LGF frequencies on chromosome 3 for type A samples."}
Acolumns <- c("B.Loss", "B.Gain", "B.Fusion")
image(bandData, what = Acolumns, chr = 3)
```
The next visual is nearly identical to 'vertical stack chromosome' withe the exception that the visual is set along the x axis instead of the y axis.
```{r h.plot2Chrom, fig.width=5, fig.height=8, fig.cap = "Horizontal stacked barplot of LGF frequencies on chromosome 3 for type A samples."}
image(bandData, Acolumns, chr = 3, horiz = TRUE)
```

## Plotting Cytoband-Level Data Along Both Sides of One Chromosome
This set of visuals allows the user to do a direct comparision between the cytogenetic events on a specified chromosome on the y axis.
```{r v.plot1Chrom, fig.width=8, fig.height=5, fig.cap = "Vertical stacked barplot of LGF frequencies on chromosome 13 for type A and B samples."}
image(bandData, what = list("B.Loss", "B.Gain"), chr = 1)
```
The next visual is similar to the previous visual except that the orientation is switched form the y axis to the x axis.
```{r h.plot1Chrom, fig.width=5, fig.height=8, fig.cap = "Horizontal stacked barplot of LGF frequencies on chromosome 13 for type A and B samples."}
image(bandData, what = list("B.Loss", "B.Gain"), chr = 1, horiz = TRUE)
```

# Idiograms

## One Data Column
The first idiogram is a visualization of the chromosomes as well as a barplot of the cytogenetic abnormalities attached to observe and possibly identify patterns. The parameters are similar to the previous visuals with the exception of chr is set to 'all' and col is changed to pal.
```{r makeid, fig.width=10, fig.height=8, fig.cap="Idiogram for one data columm."}
image(bandData, what = "B.Loss", chr = "all", pal = "orange")
```

## Contrasting Two Data Columns
This image allows you to do a comparision between two cytogenetic events on all the chromosomes.
```{r biid, fig.width=10, fig.height=8, fig.cap="Idiogram to contrast two data columms."}
image(bandData, what = list("B.Loss", "B.Gain"), chr = "all", 
      pal=c("orange", "forestgreen"))
```
The next visual is the same as the previous with the exception of the user can dictate how many total rows they want to graph.
```{r biid3, fig.width=10, fig.height=10, fig.cap="Idiogram to contrast two data columms."}
image(bandData, what = list("B.Loss", "B.Gain"), chr = "all", nrows = 3,
      pal=c("orange", "forestgreen"))
```
This visual is the same as the previous except instead of plotting on the y axis, it is instead plotted on the x axis.
```{r hbiid, fig.width=8, fig.height=10, fig.cap="Idiogram to contrast two data columms."}
image(bandData, what = list("B.Loss", "B.Gain"), chr = "all", 
      pal=c("orange", "forestgreen"), horiz = TRUE)
```

## Many Data Columns
This image allows you to graph multiple data columns of the same cytogenetic event and create a visualization of the cytogenetic event and do a comparison. This image is plotted on the y axis for each idiogram graph.
```{r stackid, fig.width=6, fig.height=14, fig.cap="Idiogram for many data columns."}
image(bandData, what = paste(LETTERS[1:2], "Loss", sep="."), chr = "all", 
              pal=c("forestgreen", "orange", "purple"), nrows=3, horiz = FALSE)
```
Lastly, this image is the same as the previous with the exception of the graphs being plotted on the y axis.
```{r hstackid, fig.width=14, fig.height=5, fig.cap="Idiogram for many data columns."}
image(bandData, what = paste(LETTERS[1:2],"Loss", sep="."), chr = "all", 
              pal=c("forestgreen", "orange", "purple"), nrows=3, horiz= TRUE)
```

# Appendix
```{r si}
sessionInfo()
```