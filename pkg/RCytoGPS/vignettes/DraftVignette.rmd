---
title: "Graphing Cytoband Data with RCytoGPS"
author: "Dwayne Tally"
date: "5/1/2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RCytoGPS}
  %\VignetteKeywords{OOMPA,CytoGPS,karyotypes,idiograms,graphics}
  %\VignetteDepends{RCytoGPS}
  %\VignettePackage{RCytoGPS}
  %\VignetteEngine{knitr::rmarkdown}
---
DOWNLOAD UMPIRE FROM R FORGE

```{r opts, echo=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=5)
```
# Introduction
Modern biological experiments are increasingly producing interesting binary matrices. These may represent the presence or absence of specific gene mutations, copy number variants, microRNAs, or other molecular or clinical phenomena. We have recently developed a tool, CytoGPS [^Abrams and colleagues], that converts conventional karyotypes from the standard text-based notation (the International Standard for Human Cytogenetic Nomenclature; ISCN) into a binary vector with three bits (loss, gain, or fusion) per cytoband, which we call the “LGF model”. To complement the website tool we have developed CytoGPSR as a package to help extract format and analyze Side of genetic data processed by CytoGPS.org. The parsing JSON script is able to parse any JSON file extracted from CytoGPS.org and format them into the LGF model binary data sets. A variety of ideogram visualizations are available to help users better interpret their cytogenetic data.

## Setup
First, you need to load the necassary library to extract data from JSON files.
```{r Setup}
library(RCytoGPS)
library(rjson)
#Idioformat has the additional values needed that is not obtained from readLGF
load("Idioformat.rda")

rnames <- function(lst, item) {
  f <- function(ll, inds) {
    if ((ii <- match(item, names(ll), FALSE)))
      list(inds=c(inds, ii), len=length(ll[[ii]]))
    else if (all(is.atomic(unlist(ll, FALSE))) || !is.list(ll))
      NULL
    else
      lapply(seq_along(ll), function(i) f(ll[[i]], inds=c(inds, i)))
  }
  unlist(f(lst, NULL))
}

## Make up sample names that include row number, padded with leading zeros
padnames <- function(prefix, values, ndigits = NULL) {
  M <- max(values)
  if (is.null(ndigits)) {
    ndigits <- trunc(log10(M))
  }
  padlength <- sapply(values, function(n) sum(n < 10^(1:ndigits)))
  pad <- sapply(padlength, function(p) paste(rep("0", p),collapse = ""))
  paste(prefix, pad, values, sep="")
}


extractOneLGF <- function(J) {
  bands <- J$iscn2016_bands # cytoband labels/names
  ## extract the status
  OUT <- J$output
  KY <- matrix(NA, ncol = 2, nrow = length(OUT))
  colnames(KY) <- c("Status", "Karyotype")
  for (I in 1:length(OUT)) {
    x <- OUT[[I]]
    kary <- x$karyotype
    stat <- x$status
    KY[I,] <- c(stat, kary)
  }
  KY <- as.data.frame(KY, stringsAsFactors = FALSE)
  rownames(KY) <- padnames("RN", 1:length(OUT))
  KY$Status  <- factor(KY$Status)
  
  ## extract the (sub)clone ids
  clone <- unlist(lapply(OUT, function(x){
    if((x$status) %in% c("Success", "Fixable grammar error and success")) {
      1:length(lapply(x$parsing_result, "[[", "loss_gain_fusion_computing"))
    }
  }))
  ## extract the binary-mapped LGF data
  lgf <- lapply(OUT, function(x) { # Get the loss data from parsing_result
    if((x$status) %in% c("Success", "Fixable grammar error and success")) {
      lgf <- lapply(x$parsing_result, "[[","loss_gain_fusion_computing")
    }
  })
  ## compute row-name IDS
  df.ID <- as.data.frame(matrix(rnames(lgf, "loss"), ncol = 4, byrow = TRUE))
  id <- df.ID$V1
  if(any(df.ID$V2 != clone)) {
    warning("Disagreement among clone IDs.")
  }
  
  fullID <- apply(df.ID[, 1:3], 1, paste, collapse=".")
  if (any(duplicated(fullID))) {
    warning("Duplicated identifiers should not happen.")
  }
  ## Extract the loss, gain, and fusion binary data separately
  loss1 <- sapply(lgf, function(x){
    lapply(x, "[[","loss")
  })
  df_Loss <- as.data.frame(matrix(unlist(loss1), ncol = 916, byrow = TRUE),
                           stringsAsFactors = FALSE)
  colnames(df_Loss) <- paste("Loss", bands, sep = "_")
  
  gain1 <- sapply(lgf, function(x){
    lapply(x, "[[","gain")
  })
  df_Gain <- as.data.frame(matrix(unlist(gain1), ncol = 916, byrow = TRUE),
                           stringsAsFactors = FALSE)
  colnames(df_Gain) <- paste("Gain", bands, sep = "_")
  fusion1 <- sapply(lgf, function(x){
    lapply(x, "[[","fusion")
  })
  df_Fusion <- as.data.frame(matrix(unlist(fusion1), ncol = 916, byrow = TRUE),
                             stringsAsFactors = FALSE)
  colnames(df_Fusion) <- paste("Fusion", bands, sep = "_")
  ## Put them back together
  df.lgf <- cbind(df_Loss, df_Gain, df_Fusion)
  rownames(df.lgf) <- fullID
  df.lgf$ID = id
  df.lgf$Clones = clone
  w <- which(colnames(df.lgf) == "ID")
  df.lgf <- df.lgf[, c(w:(w + 1), 1:(w-1))]  
  #formats and column sums the LGF dataframe for cytoData
  cytoData <- Idioformat(df.lgf)
  rownames(cytoData) <- cband
  
  list(Status = KY, LGF = df.lgf, cytoData = cytoData)
}

readLGF <- function(files = NULL, folder = NULL) {
  ## Figure out which files we want to read
  if (is.null(folder)) {
    folder  <-  "."
  }
  if (is.null(files)) {
    files  <- list.files(folder, pattern = "*.json", full.names = TRUE) # character vector , one file per entry
  }
  if (length(files) < 1) {
    stop("No JSON input files to read.")
  }
  message("Reading ", length(files), " file(s) from '", folder, "'.\n")
  
  ## make sure that, when done,  we leave the working directory in the same state that we found it.
  home <- getwd()
  on.exit(setwd(home))
  setwd(folder)
  
  ## It might get large -- not said by Davis Guggenheim
  myJSON <- lapply(files, function(x) fromJSON(file = x)) # a list, one element per JSON file
  temp  <- lapply(myJSON, extractOneLGF)
  temp
}



Idioformat <- function(df){
  #element name will be the same as karyotype
  #first example loss.1, loss.2
  Chromosome <- Chromosome
  loc.start <- loc.start
  loc.end <- loc.end
  arm <- arm
  Band <- band
  #row.names(df) <- cband
  Loss <- df[, grepl("Loss", names(df))]
  Gain <- df[, grepl("Gain", names(df))]
  Fusion <- df[, grepl("Fusion", names(df))]
  
  
  data.frame(Chromosome = Chromosome, 
                    loc.start = loc.start,
                    loc.end = loc.end,
                    arm = arm,
                    Band = Band, 
                    Loss = colSums(Loss), Gain = colSums(Gain), Fusion = colSums(Fusion))
  #row.names(df) <- cband
  
}
```
# Extracting JSON data and formatting to LGF model
readLGF is a function built within the RCytoGPS package. The function readLGF takes the parameters of a specific file name, from a specified directory/folder, and extracts and formats the JSON dataset into a LGF nested list. This is done by using two built in functions called extractOneLGF to parse the data obtain from the JSON(s) file and to format the data into a binary vector and the other function is rnames to build unique IDs based on the karyotype elements extracted. Alternatively readLGF will also accept all JSON files from a specified directory if the file name is not specified.
```{r Extracting JSON data and formating to LGF model}
wd <- ("C:/Users/firem/Documents/input_outputDirectory")
temp <- readLGF(folder = wd)
```
# Extracting and formating Idiograph data
The purpose of this code is taking the output of readLGF, to extract and format IdioData based of the LGF model. to match the necassary data columns for generating Idiographs. We load Idioformat.rda that contains the columns of Chromosome, loc.start, loc.end, band, arm, and cband. Then we concatinate the column sum of the LGF with the data columns from Idio.rda.
```{r Extracting and formating Idiograph data}
cytoData <- lapply(temp, function(x){
  return(x$cytoData)
})

cytoData <- data.frame(cytoData)

cytoData[,9:13] <- NULL

colnames(cytoData)[which(names(cytoData) == "Loss")] <- "A.Loss"
colnames(cytoData)[which(names(cytoData) == "Gain")] <- "A.Gain"
colnames(cytoData)[which(names(cytoData) == "Fusion")] <- "A.Fusion"
colnames(cytoData)[which(names(cytoData) == "Loss.1")] <- "B.Loss"
colnames(cytoData)[which(names(cytoData) == "Gain.1")] <- "B.Gain"
colnames(cytoData)[which(names(cytoData) == "Fusion.1")] <- "B.Fusion"

```

# Turning CytoData into an S4 Object
The purpose of this code is to transfrom the CytoData, into an S4 object using the function cytobandData located in the RcytoGPS package. CytobandData is used to obtain more detailed information of the CytoData such as looking for specific arms or bands of a cytogenetic abnormality. The newly aquired s4 object will then be used in generating Idiographs. Class is used to show the user where cytobandData is from and summary is to get some basic information from bandData.
```{r Turning CytoData into an S4 Object}
bandData <- CytobandData(cytoData)

```
## Generating Graphs

# Plotting Cytoband Data Along the Genome
The first visual is to show the user that they can generate graphs using different data sets obtained from different karyotypes. This is important because it allows an easier visual comparisons between the same cytogenetic abnormality but using different karyotype data. The arugments for the function is the dataset, a specified column name, and the col or color you want the graphs to be.
```{r gb, fig.cap="Cytoband level data along the genome.", fig.width=10, fig.height=5}
opar <- par(mfrow=c(2,1))
barplot(bandData, what = "B.Loss", col = "forestgreen")
par(opar)
```

# Single Chromosome Plots
Note: "Horizontal" and "vertical" refer to the direction of the chromosome with its cytoband shading.
## Plotting Cytoband-Level Data Along One Chromosome
This graph allows you to simultaneously compare multiple mulitple cytogenetic events. The cytogenetic events are typically obtained from the same karyotypes but does not have to be. The parameters are similar to the previous graph, except you can have a variable that has the column names of the columns you want to analyze, and a specific chromosome you want to look at.
```{r v.plot2Chrom, fig.width=8, fig.height=5,fig.cap = "Vertical stacked barplot of LGF frequencies on chromosome 3 for type A samples."}
Acolumns <- c("B.Loss", "B.Gain", "B.Fusion")
image(bandData, what = Acolumns, chr = 1)
```
Similar graph as the previous that takes in the same parameters, the sole difference is that the graph is presented along the x axis instead of the y axis. The purpose is for user preference, if they want to see a visual graph on the x axis instead of the y axis.
```{r h.plot2Chrom, fig.width=5, fig.height=8, fig.cap = "Horizontal stacked barplot of LGF frequencies on chromosome 3 for type A samples."}
image(bandData, Acolumns, chr = 13, horiz = TRUE)
```

# Idiograms

## One Data Column
This is the first of the Idiogram graphs you can make. The purpose of this graph is to have a visualization of the chromosomes as well as a barplot of the cytogenetic abnormalities attached to observe and possibly identify patterns.This function takes similar arguemnts to the previous except to change the color you have to use the argument pal.
```{r makeid, fig.width=10, fig.height=8, fig.cap="Idiogram for one data columm."}
image(bandData, what = "B.Loss", chr = "all", pal = "orange")
```

## Contrasting Two Data Columns
This graph shows the user that they are able to compare and contrast two cytogenetic events simultaneously. The user can compare cytogenetic events from the same karyotypes or different ones. The arguments are similiar to the previous ones, except what has to take in a list containing exactly two columns with the column names of the cytogenetic abnormalities you want to observe, and pal has to take in two different colors.
```{r biid, fig.width=10, fig.height=8, fig.cap="Idiogram to contrast two data columms."}
image(bandData, what = list("B.Gain","B.Fusion"), chr = "all", 
      pal=c("orange", "forestgreen"))
```

# Gallery
To see all possible visuals please go to our gallery for images.

# Appendix
SessionInfo() is used to get information on the local machine that ran the code. This is mostly for reproducibility purposes.
```{r}
sessionInfo()

```